import {toRegExpDetails} from '../src/index.js';
import {areMatchDetailsEqual, color, cp, err, ok, onigurumaResult, r, transpiledRegExpResult, value} from './script-utils.js';
/**
@import {MatchDetails} from './script-utils.js';
*/

/*
A command line Oniguruma tester that compares results with JS regexes generated by this library.
Run it using any of the following commands:

$ node scripts/onig-match.js '…' '…'
$ pnpm onig:match '…' '…'
$ npm run onig:match '…' '…'

The first argument is the regex pattern and the second is the target string.

Additional features:

Insert characters by code point in the target string using `\u{…}`:
$ pnpm onig:match '\n' '\u{A}'

Don't compare to Oniguruma-To-ES results:
$ pnpm onig:match '…' '…' no-compare
*/

const agent = process.env.npm_config_user_agent;
const env = agent ? (agent.startsWith('pnpm/') ? 'pnpm' : 'npm') : 'node';

exec(process.argv.slice(2));

async function exec(args) {
  const processedArgs = getArgs(args);
  if (!processedArgs) {
    err(null, 'pattern and target args expected');
    return;
  }
  const {pattern, target, options} = processedArgs;
  printInput(pattern, target);
  const warnings = [];

  const onigMatches = [];
  const onigT0 = performance.now();
  let onigMatch = await onigurumaResult(pattern, target, 0);
  const onigT1 = performance.now();
  let onigNextPos = getNextPos(onigMatch);
  while (onigMatch.result !== null) {
    onigMatches.push(onigMatch);
    if (onigMatch.index === target.length) {
      // Guard against zero-length match at the end of the string, since setting the search `pos`
      // beyond the string's length doesn't prevent a search
      break;
    }
    onigMatch = await onigurumaResult(pattern, target, onigNextPos);
    if (onigMatch.result !== null) {
      if (onigMatch.index < onigNextPos) {
        warnings.push(`Oniguruma match pos (${onigMatch.index}) < search pos (${onigNextPos}) - likely 0-len match between surrogate pair`);
        onigNextPos++;
      } else {
        onigNextPos = getNextPos(onigMatch);
      }
    }
  }
  printOnigResults(onigMatch, onigMatches);
  console.log(color('gray', `⚡ Oniguruma: ${(onigT1 - onigT0).toFixed(3)}ms (1st search, with WASM load)`));

  if (!options.compare) {
    console.log(color('gray', '⏩ Skipped library comparison'));
    printWarnings(warnings);
    return;
  }

  const libMatches = [];
  const libT0 = performance.now();
  let libMatch = transpiledRegExpResult(pattern, target, 0);
  const libT1 = performance.now();
  let libNextPos = getNextPos(libMatch);
  while (libMatch.result !== null) {
    libMatches.push(libMatch);
    libMatch = transpiledRegExpResult(pattern, target, libNextPos);
    if (libMatch.result !== null) {
      if (libMatch.index < libNextPos) {
        warnings.push(`Library match pos (${libMatch.index}) < search pos (${libNextPos}) - likely 0-len match between surrogate pair`);
        libNextPos++;
      } else {
        libNextPos = getNextPos(libMatch);
      }
    }
  }
  console.log(color('gray', `⚡ Library: ${(libT1 - libT0).toFixed(3)}ms (1st search, with transpilation)`));
  try {
    if (toRegExpDetails(pattern).options) {
      console.log(color('gray', '✨ Library used a RegExp subclass'));
    }
  } catch {
    // Ignore error; it's already been captured in the `libMatch` result
  }
  printWarnings(warnings);
  printLibComparison(onigMatch, onigMatches, libMatch, libMatches);
}

function getArgs([pattern, target, ...rest]) {
  if (typeof pattern !== 'string' || typeof target !== 'string') {
    return null;
  }
  const compare = !rest.includes('no-compare');
  // HACK: pnpm, unlike npm, auto-escapes backslashes in string args, so undo that here
  if (env === 'pnpm') {
    pattern = pattern.replace(/\\\\/g, '\\');
    target = target.replace(/\\\\/g, '\\');
  }
  // HACK: Replace unescaped `\u{…}` in the target string with the referenced code point
  target = target.replace(
    /\\u\{([^\}]+)\}|\\?./gsu,
    (m, code) => m.startsWith(r`\u{`) ? cp(parseInt(code, 16)) : m
  );
  return {
    pattern,
    target,
    options: {
      compare,
    },
  };
}

function getNextPos(match) {
  return match.index + (match.result?.length || 1);
}

/**
@param {string} pattern
@param {string} target
*/
function printInput(pattern, target) {
  if (env === 'node') {
    // Add a blank line for readability
    console.log('');
  }
  console.log('Pattern:', color('yellow', `/${pattern}/`), color('gray', 'ONIG_OPTION_CAPTURE_GROUP enabled'));
  const length = target.length;
  const cpLength = [...target].length;
  const lengthStr = `(len: ${length}${cpLength !== length ? `, code point len: ${cpLength}` : ''})`;
  console.log('String:', `${value(target)} ${color('gray', lengthStr)}`);
}

/**
@param {MatchDetails} onigResult
@param {Array<MatchDetails>} onigMatches
@param {MatchDetails} libResult
@param {Array<MatchDetails>} libMatches
@returns {boolean} Whether the results are the same
*/
function printLibComparison(onigResult, onigMatches, libResult, libMatches) {
  if (!!libResult.error !== !!onigResult.error) {
    err(null, `Oniguruma and library results differed (only ${libResult.error ? 'library' : 'Oniguruma'} threw error)`);
  } else if (libMatches.length !== onigMatches.length) {
    err(null, `Oniguruma and library had different number of results (${onigMatches.length}, ${libMatches.length})`);
  } else {
    let hasDiff = false;
    for (let i = 0; i < libMatches.length; i++) {
      if (!areMatchDetailsEqual(libMatches[i], onigMatches[i])) {
        hasDiff = true;
        break;
      }
    }
    if (hasDiff) {
      err(null, 'Oniguruma and library results differed');
      console.log('Library results:', libMatches);
    } else {
      ok(null, 'Results same for Oniguruma and library');
      return true;
    }
  }
  return false;
}

/**
@param {MatchDetails} result
@param {Array<MatchDetails>} matches
*/
function printOnigResults(result, matches) {
  if (result.error) {
    err(null, `Oniguruma error: ${result.error.message}`);
  } else {
    const output = matches.length ?
      (matches.length > 1 ? matches : matches[0]) :
      `${color('gray', 'No match')}`;
    console.log(`Oniguruma results (${matches.length}):`, output);
  }
}

function printWarnings(warnings) {
  if (!warnings.length) {
    return;
  }
  for (const warning of warnings) {
    console.log(color('gray', `❗ ${warning}`));
  }
}
